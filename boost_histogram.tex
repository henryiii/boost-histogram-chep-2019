\documentclass{webofc}
\usepackage[varg]{txfonts}   % Web of Conferences font
\usepackage{hyperref}

%
% Put here some packages required or/and some personnal commands
%
%
\begin{document}
%
\title{Recent developments in histogram libraries}

\author{\firstname{Hans Peter} \lastname{Dembinski}\inst{1} \and
        \firstname{Jim} \lastname{Pivarski}\inst{2} \and
        \firstname{Henry} \lastname{Schreiner}\inst{2}\fnsep\thanks{\email{hschrein@cern.ch}}
        % etc.
}

\institute{
	Max Planck Institute for Nuclear Physics, Heidelberg, Germany
\and
    Princeton University, Princeton, USA
}

\abstract{%
Boost.Histogram, a header-only C++14 library that provides multi-dimensional histograms and profiles, is now available in Boost-1.70. It is extensible, fast, and uses modern C++ features. Using template meta-programming, the most efficient code path for any given configuration is automatically selected. The library includes key features designed for the particle physics community, such as optional under- and overflow bins, weighted increments, reductions, growing axes, thread-safe filling, and memory-efficient counters with high-dynamic range.

Python bindings for Boost.Histogram are being developed in the Scikit-HEP project to provide a fast, easy-to-install package as a backend for other Python libraries and for advanced users to manipulate histograms. Versatile and efficient histogram filling, effective manipulation, multithreading support, and other features make this a powerful tool. This library has also driven package distribution efforts in Scikit-HEP, allowing binary packages hosted on PyPI to be available for a very wide variety of platforms.

Two other libraries fill out the remainder of the Scikit-HEP Python histogramming effort. Aghast is a library designed to provide conversions between different forms of histograms, enabling interaction between histogram libraries, often without an extra copy in memory. This enables a user to make a histogram in one library and then save it in another form, such as saving a Boost.Histogram in ROOT. And Hist is a library providing friendly, analyst-targeted syntax and shortcuts for quick manipulations and fast plotting using these two libraries.
}

\maketitle

\section{Introduction}
\label{intro}

There is no shortage of histogramming libraries for Python (see Table 1). However, many/most of these are abandoned, have a narrow focus, and most importantly, have little or no interaction with other histogramming libraries. For the Scikit-HEP family


% This table may move to a webpage somewhere instead.

For a collection of some of the histogram libraries currently available in Python see Table~\ref{tab-1}.

\begin{table}
	\centering
	\caption{Histogram libraries for Python. For the PyPI column, "Pure" means the library is pure Python, "Wheels" means it is compiled but binary wheels are available, "Source" means the code is there, but must be compiled and may require other dependencies, and "No" means it is not hosted on PyPI. Old projects that predate universal (pure python) wheels may be incorrectly listed as "Source".}
	\label{tab-libraries}       % Give a unique label
	\begin{tabular}{llll}
		\hline
		Library                                                                      & Updated & PyPI   & Notes                                                \\ \hline
		\href{https://www.numpy.org/}{numpy}                                         & 2019         & Wheels & Very simple histogramming functions                  \\
		\href{https://coffeateam.github.io/coffea/notebooks/histograms.html}{coffea} & 2019         & Pure   & Family of tools for HEP Columnar analysis            \\
		\href{https://histogrammar.org}{Histogrammar}                                & 2019         & Pure   & Multilanguage, limited support                       \\
		\href{https://pygram11.readthedocs.io}{pygram11}                             & 2019         & Wheels & Unix only, Python 3 only                             \\
		\href{https://root.cern.ch/pyroot}{PyROOT}                                   & 2019         & No     & CERN's ROOT, UNIX binaries on conda-forge            \\
		\href{https://yoda.hepforge.org}{YODA}                                       & 2019         & No     & HEP tool for MCnet                                   \\
		\href{https://physt.readthedocs.io/en/latest/tutorial.html}{physt}           & 2019         & Pure   & Non-HEP specific tool                                \\
		\href{https://github.com/astrofrog/fast-histogram}{fast-histogram}           & 2019         & Yes    & Fast but limited                                     \\
		\href{https://vaex.io}{Vaex}                                                 & 2019         & Source & Large system for data analysis                       \\
		\href{https://pypi.org/project/hdrhistogram/}{hdrhistogram}                  & 2019         & Source & Multilanguage, large range                           \\
		\href{https://pypi.org/project/multihist/}{multihist}                        & 2019         & Pure   & Numpy wrapper for syntax                             \\
		\href{https://github.com/scikit-hep/histbook}{HistBook}                      & 2018         & Pure   & Archived, Replaced by boost-histogram / hist         \\
		\href{https://pypi.org/project/qhist/}{qhist}                                & 2018         & Source & ROOT required, Python 2.7 only                       \\
		\href{https://github.com/theodoregoetz/histogram}{theodoregoetz}             & 2018         & No     & Tried to combine many of the above                   \\
		\href{https://github.com/drdavis/rootplotlib}{rootplotlib}                   & 2016         & No     & ROOT backend                                         \\
		\href{https://pypi.org/project/matplotlib-hep/}{matplotlib-hep}              & 2016         & Source & Focused on plotting                                  \\
		\href{https://github.com/jpivarski/svgfig}{SVGFig}                           & 2016         & No     & Plotting framework                                   \\
		\href{https://github.com/jpivarski/plothon}{Plothon}                         & 2015         & No     & Predecessor to SVGFig                                \\
		\href{https://pypi.org/project/pyhistogram/}{pyhistogram}                    & 2014         & Pure   & Inspired by rootpy                                   \\
		\href{https://pypi.org/project/pypeaks}{pypeaks}                             & 2014         & Pure   & Peak detection                                       \\
		\href{https://github.com/opendatagroup/cassius}{Cassius}                     & 2013         & No     & Statistical Modeling Package                         \\
		\href{https://pypi.org/project/histogramy}{histogramy}                       & 2013         & Pure   & 1D with some fitting tools                           \\
		\href{https://pypi.org/project/histogram}{histogram}                         & 2011         & Source & For Distributed Data Analysis for Neutron Scattering \\
		\href{https://pypi.org/project/SimpleHist/}{SimpleHist}                      & 2011         & Pure   & Numpy based                                          \\
		\href{https://pypi.org/project/paida/}{paida}                                & 2007         & Source & Analysis and plotting                                \\ \hline
	\end{tabular}
\end{table}

\section{Boost.Histogram for C++}
\label{sec-bh-cpp}

% Ideas:
%
% * Basic overview
% * Include everything mentioned in abstract if possible: optional under- and overflow bins, weighted increments, reductions, growing axes, thread-safe filling, and memory-efficient counters with high-dynamic range.
% * Highlight dynamic features that enable Python (or other) bindings (handy place to highlight compile time benefits when dynamic axes, etc not needed)
% * Describe 1.72's high performance .fill
% * Include performance plot from slides, diagram from slides (I can add images to repo later - Henry)

Boost.Histogram is a header-only C++14 library which implements feature-rich multi-dimensional generalized histograms. It is part of the \href{https://www.boost.org/}{Boost C++ Libraries} and only depends on a few other header-only libraries from the Boost project and the C++ standard library. The feature set of Boost.Histogram was designed with the needs of the (astro)particle physics community and the wider data analysis community in mind. In particular, feature parity with the histogram implementations from the \href{https://root.cern.ch/}{ROOT framework} and the \href{https://www.gnu.org/software/gsl/}{GNU Scientific Library} was a central goal.

The library was designed to be easy to use for the casual user, while offering a high amount flexibility and extensibility for the power user. In a classic C++ design based on run-time polymorphism, flexibility and extensibility comes at the cost of performance. Boost.Histogram avoids the run-time trade-off and achieves higher performance than other libraries with static polymorphism based on templates and modern template meta-programming.

Compatibility with other Boost libraris and the C++ standard library was another central design goal. By instead adhering to standard interfaces, the library avoids to duplicate functionality provided by other libraries, especially the standard library. For example, these are one-liners:
\begin{itemize}
\item Sum all counts with \verb|std::accumulate|.
\item Find the cell with the highest count with \verb|std::max_element|.
\item Compute the cumulative distribution with \verb|std::partial_sum|.
\end{itemize}

\subsection{Generalized histograms}
\label{sec-bh-cpp-gen}

A histogram in the common sense is a collection of counts $n_i$, where each is associated to an interval out of a sequence of non-overlapping consecutive intervals, called \emph{bins}. When a value $x$ is passed to a histogram, the bin $i$ is found which contains $x$ and the associated count $n_i$ is incremented. A multi-dimensional histogram accepts value tuples $(x, y, z, \dots)$. For each value of the tuple an independent sequence of bins exists, which we call an \emph{axis}. The count is now looked up based on an multi-dimensional index $(i,j,k,\dots)$ obtained from the mappings $(x \rightarrow i, y \rightarrow j, z \rightarrow k, \dots)$.

Boost.Histogram generalizes the classic histogram concept in three ways.
\begin{description}
\item[Custom axis objects.] The mapping from input value to index provided by an axis $x \rightarrow i$ can be completely user-defined. Values are not restricted to numbers, arbitrary C++ objects can be used as values when an appropriate mapping is provided, for example strings. Bins do not have to be consecutive, they can have gaps and arbitrary hyperdimensional shapes. Hexagonal binning is possible, for instance, or bins that are HEALPIX pixels (although neither are currently implemented).

\item[Custom accumulators.] The counts in a generalized histogram can be replaced by user-defined accumulators. Accumulators can take any number of \emph{samples}, which like values can be arbitrary C++ objects. Values and samples are passed to the generalized histogram together; values are converted to indices which address the accumulator, and samples are passed to the accumulator. The library provides a few standard accumulators, for example, to compute mean and variance of samples in each bin. This is called a \emph{profile} in the ROOT framework and a separate class, while it is just another kind of histogram in Boost.Histogram.

\item[Custom storages.] It is possible to completely customize how counts (or accumulators) are allocated and addressed in memory. The sub-component responsible for this is called a \emph{storage}. The histogram class converts the multi-dimensional index $(i,j,k,\dots)$ into a single linear index, which is passed to the storage. The standard storage allocates memory upfront for all cells and places the counts sequentially in memory, using the linear index as a memory offset. This gives the best look-up performance and is space-efficient for densely filled histograms, since it is not necessary to store the linear index explicitly for each cell. The downside of dense storage is that all cells take up space, even if they contain zero counts. The library also supports sparse storage based on an STL-compliant hash map. Only cells with non-zero counts use space in such a sparse storage, but each cell has to store its linear index in addition to the payload and some overhead for hash-based addressing.

The memory allocation strategy of a storage can be customized as well. The standard storage allocates memory dynamically from the heap, but the library builtin support for a storage based a fixed-size stack-based memory buffer. The latter allows one to efficiently create and destroy many small histograms, for example. The builtin \verb|unlimited_storage| dynamically allocates memory to grow the counter capacity as needed, starting a single byte per cell up to arbitrarily many bytes (limited by available memory only). This storage offers a unique no-overflow-guarantee and is memory-efficient in high dimensions, where the number of cells is large and the small memory footprint per cell pays off.
\end{description}

The three sub-components of a generalized histogram, axis types, storages, and accumulators, are orthogonal. This means that any sub-component can be replaced or modified independently of the others. Orthogonal design is very powerful since it offers a huge customization potential from all possible combinations.

\subsection{Notable features}
\label{sec-bh-cpp-feat}

We briefly list other notable features here.

\begin{description}
\item[Arithmetic operators.] Histograms support the standard math operators $+, -, \cdot, /$.

\item[Growing axes.] A standard axis has a fixed value range and number of bins, defined at the time of construction. The library also supports growing axis, whose initial range and bin number grows with the input. If a value is encountered that would fall outside of the axis range, the axis range is extended to contain the value and the number of bins is increased.

\item[Optional underflow and overflow bins.] Each axis of the histogram can have optional underflow and overflow bins. These are extra bins beyond the defined range of the axis, they count all values which fall below the smallest value on the axis or above the largest value, respectively. The existence or absense of these bins is mostly transparent for the user. They are very useful to detect outliers and to offer lossless reductions (explained below).

\item[Reductions.] The library offers tools to reduce the memory footprint of a histograms by reducing the number of bins of an axis or by completely removing an axis. The number of bins of an axis can be reduced by shrinking its value range and/or by merging any number of adjacent bins into one larger bin. Likewise, an axis can be removed completely by summing over its bins (a so called \emph{projection}). In both cases, the presence of underflow and overflow bins guarantees that the reduced histogram is identical to one obtained that was filled with the orginal values. This is general not possible when underflow and overflow bins are missing.

\item[Thread-safe filling of histograms.] Filling histograms with values is not thread-safe in general, but the library offers a builtin thread-safe counter based on a \verb|std::atomic| integer type and a thread-safe locking infrastructure for storages, the latter is needed when growing axes are present, which can trigger a resizing of the storage.

\item[Static and dynamic axis configuration.] The library supports both histograms with static and dynamic axis containers. A histogram with a static axis container is fixed at compile-time in the number and types of axes. Vice-versa, number and axis types can vary at run-time for a dynamic axis holder. The static axis container produces histograms which are more performant, as the compiler can find more opportunities to optimize the code. When Boost.Histogram is used as a backend in a run-time environment like Python, however, axes must be configurable at run-time. The performance difference vanishes when the histogram is filled with chunks of values at once, see next item.

\item[Filling individual values and chunks of values.] Histograms can be filled with one value at once or by passing a contiguous chunk of values at once. Both cases are handled by separate code segments, which were highly optimized for performance. Passing contiguous chunks of values is up to five times faster for chunks of moderate size (32768 values) than filling one value at a time, and therefore preferred when chunks are available. Using the chunk code for single values would be slow, however, and therefore the other optimized code path exists.
\end{description}

\section{boost-histogram for Python}
\label{sec-bh-py}


% Hans, please adjust/expand this paragraph as needed! - Henry
Boost.Histogram was developed with Python in mind. Original prototype bindings using Boost.Python were included in the original draft submitted to Boost; however, to keep the library focused they were removed before the first release. New bindings based on PyBind11 were developed as part of the Scikit-HEP family of Python packages.

The new bindings were designed to be ...

\subsection{Design}
\subsection{Flexibility}
\subsection{Speed}
\subsection{Distribution}

\section{The Scikit-HEP family}
\label{sec-3}

\subsection{Hist}
\subsection{Aghast}
\subsection{The Scikit-HEP family}

Don't forget to give each section, subsection, subsubsection, and
paragraph a unique label (see Sect.~\ref{sec-bh-cpp}).

\section{Summary}
\label{sec-4}

% BibTeX or Biber users please use (the style is already called in the class, ensure that the "woc.bst" style is in your local directory)
% \bibliography{name or your bibliography database}


\end{document}
